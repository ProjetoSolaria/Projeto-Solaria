<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="../estilos-css/estilo-artigos.css">
    <link rel="shortcut icon" href="../imagens/favicon.ico" type="image/x-icon">
    <link rel="stylesheet" href="../estilos-css/menu.css">
    <script defer src="../codigo-js/menu.js"></script>
    <title>Funcionamento</title>
</head>
<body>
  <header class="header">
    <nav class="nav">
      <a href="index.html" class="logo">Solaria</a>
      <button class="hamburger"></button>
      <ul class="nav-list">
        <li><a href="index.html">Solaria</a></li>
        <li><a href="sobre-o-projeto.html">Sobre o Projeto</a></li>
        <li><a href="inscricoes.html">Inscrições</a></li>
      </ul>
    </nav>
  </header>
    <main>
        <h1>Como funciona o nosso projeto?</h1>
        <p>A ideia para o nosso projeto é construir um seguidor solar e um medidor de energia. O seguidor solar é controlado por um algoritmo que utiliza sensores para rastrear a posição do sol no céu. Esses dados são usados para mover os painéis solares em tempo real. Paralelamente, o medidor de energia coleta informações dos dispositivos conectados e fornece uma visão abrangente do consumo energético, permitindo ajustes e tomada de decisões informadas. Nosso projeto tem vastas possibilidades de aplicação, desde residências e comunidades até sistemas comerciais e industriais. Ele pode ser adaptado para uso em áreas remotas ou como parte integrante de redes elétricas urbanas. </p>
        <h2>Materiais e Código: Seguidor Solar</h2>
        <p>Desenvolvemos um seguidor solar que altera a posição dos módulos fotovoltaicos ao longo do dia, seguindo o caminho do sol, no nosso protótipo, seguiria de acordo com a luz no LDR.</p>
        <p>Para criarmos esse projeto, usamos os seguintes materiais:  </p>
        <ul>
          <li>Placa Arduíno Uno;</li>
          <li>1 LDR;</li>
          <li>1 Micro Servo 9g Sg90;</li>
          <li>1 Placa Solar 107x61MM;</li>
          <li>1 Resistor 1  kΩ;</li>
          <li>1 Protoboard;</li>
          <li>1 LED Vermelho</li>
        </ul>
        <p>Arduino é uma plataforma de prototipagem eletrônica, serve para facilitar o aprendizado de programação, ensinando as pessoas a desenvolverem projetos de eletrônica e de robótica, automatizar escritório, criar um novo brinquedo ou jogos, etc.</p>

        <img src="../imagens/arduino.jpg" alt="Placa Arduino">

        <p>O LDR (Light Dependent Resistor) também é conhecido como fotoresistor, é um tipo de resistor que tem a capacidade de variar a sua resistência em função da intensidade de luz que incide sobre ele.</p>

        <img src="../imagens/ldr.jpg" alt="">

        <p>O Micro Servo Motor SG90 9g é um item essencial para projetos de robótica, mecatrônica e diversos outros projetos. </p>

        <img src="../imagens/servo.jpg" alt="Micro Servo Motor SG90">
                                                      
        <p>Os resistores são componentes passivos que compõem os circuitos elétricos. A sua finalidade é limitar o fluxo de corrente elétrica em um determinado circuito, além de realizar a conversão de energia elétrica em energia térmica através do efeito joule.</p>

        <img src="../imagens/resistores.jpg" alt="Resistores">
        
        <p>Uma placa de ensaio ou matriz de contato (protoboard ou breadboard em inglês) é uma placa com furos e conexões condutores utilizada para a montagem de protótipos e projetos em estado inicial.</p>

        <img src="../imagens/protoboard.jpg" alt="Protoboard">
                                      
        <p>O LED vermelho geralmente serve como indicador de status ou sinalização intermediária durante a execução do programa. Pode ser programado para fornecer informações visuais sobre diferentes estados do sistema ou para sinalizar eventos específicos, contribuindo para a depuração e interação com o dispositivo.</p>

        <img src="../imagens/led.jpg" alt="">

        <p>Para a montagem do seguidor solar, criamos um esquema por meio do site Tinkercad, conforme a imagem abaixo:</p>

        <img src="../imagens/esquema-seguidor-de-luz.jpg" alt="Esquema do Seguidor Solar">
        
        <p>O nosso esquema foi criado seguindo as informações do código:</p>
        <pre>
          <code>
#include &lt;Servo.h&gt;
Servo servoX;
Servo servoY;
int ldr1Pin = A0; // LDR 1 pino
int servoYPin = 10; // Pino servo Y
int ldr1Value;
int servoYAngle;

void setup() {
  servoY.attach(servoYPin);
}

void loop() {
  ldr1Value = analogRead(ldr1Pin); // Ler os valores do LDR
  servoYAngle = map(ldr1Value, 0, 1023, 0, 180); // Mapeie valores LDR para ângulos do servo
  servoY.write(servoYAngle) // Definir ângulos de servo
  delay(50); 
}
            </code>
        </pre>
        <br>
        <p>A função <strong>loop()</strong> é onde o código principal é executado em um loop contínuo após a inicialização. <strong>ldr1Value</strong> recebe o valor lido do sensor LDR usando a função. analogRead(ldr1Pin), que converte a leitura analógica para um valor digital. Em seguida, o valor lido do LDR é mapeado para um ângulo de servo utilizando a função <strong>map()</strong>. Isso permite que a variação do sensor LDR seja convertida em uma faixa de ângulos entre 0 e 180 graus, adequada para o servo motor. <strong>servoY.write(servoYAngle)</strong> envia o ângulo calculado para o servo Y, fazendo-o mover-se para a posição correspondente. <strong>delay (50)</strong> introduz um pequeno atraso de 50 milissegundos entre as iterações do loop, permitindo um controle suave do servo e evitando movimentos bruscos. </p>

        <h2>Materiais e Código: Medidor de Energia</h2>

        <p>Também desenvolvemos um medidor de energia para medir a potência no ciclo de vida do dispositivo. Para fazer esse projeto, usamos os seguintes materiais: </p>

        <ul>
          <li>ESP8266;</li>
          <li>1 Sensor de corrente não invasivo SCT-013;</li>
          <li>2 resistores de 10 kΩ;</li>
          <li>1 resistor de 33 kΩ;</li>
          <li>1 Capacitor Eletrolítico de 100uf X 200v;</li>
        </ul>

        <p>O ESP8266 é um microcontrolador que pode fornecer a qualquer projeto a capacidade de conexão wireless com a internet.</p>

        <img src="../imagens/esp8266.jpg" alt="ESP8266">
 
        <p>Sensor de corrente não invasivo de 30A AC - SCT-013-030 é um sensor que lê a corrente de forma não intrusiva através do efeito Hall. Ele lê corrente até 30A de forma simples e rápida sem interromper o circuito via Arduino ou Pic.</p>

        <img src="../imagens/Sensor de corrente.jpg" alt="Sensor de Corrente">
         
        <p>Um resistor de 10K é um dispositivo amplamente utilizado em equipamentos elétricos e circuitos eletrônicos. Com ele, você pode gerar calor, limitar a corrente e criar quedas de tensão. Um resistor é um componente cujo objetivo é bloquear o fluxo de eletricidade através de seu material.</p>

        <img src="../imagens/resistores 3.jpg" alt="Resistor 10k">
         
        <p>Um resistor de 33k ohms é um componente eletrônico que oferece uma resistência de 33.000 ohms à passagem de corrente elétrica. Ele é utilizado para controlar a intensidade da corrente em circuitos eletrônicos, ajustando a tensão ou limitando o fluxo de elétrons. Sua cor de faixa é laranja, laranja e laranja, indicando o valor e a tolerância.</p>

        <img src="../imagens/resistor 2.jpg" alt="Resistor 33k">
        
        <p>Segue o esquema do medidor de energia</p>

        <img src="../imagens/esquema-medidor.jpg" alt="Esquema do Medidor de Energia">

        <p>O esquema segue o seguinte código:</p>
        <pre>
          <code>
#include &lt;WiFiManager.h&gt;
#include &lt;PubSubClient.h&gt;
#include "EmonLib.h"

EnergyMonitor emon1;
int pinSCT = A0;   //Pino analógico conectado ao SCT-013
int tensao = 127;
int potencia;

WiFiClient wifiClient;                        

//MQTT Server
const char* BROKER_MQTT = "broker.hivemq.com"; //URL do broker MQTT que se deseja utilizar
int BROKER_PORT = 1883;                      // Porta do Broker MQTT

#define ID_MQTT  "MEnergia"            //Informe um ID unico e seu. Caso sejam usados IDs repetidos a ultima conexão irá sobrepor a anterior.
#define TOPIC_PUBLISH "topico1"    //Informe um Tópico único. Caso sejam usados tópicos em duplicidade, o último irá eliminar o anterior.
PubSubClient MQTT(wifiClient);        // Instancia o Cliente MQTT passando o objeto espClient

//Declaração das Funções
void mantemConexoes();  //Garante que as conexoes com WiFi e MQTT Broker se mantenham ativas
void conectaWiFi();     //Faz conexão com WiFi
void conectaMQTT();     //Faz conexão com Broker MQTT
void enviaPacote();     //

void setup() {
  Serial.begin(115200);
  conectaWiFi();
  MQTT.setServer(BROKER_MQTT, BROKER_PORT);
  //Configuração so SCT013  
  emon1.current(pinSCT, 87);
}

void loop() {
  mantemConexoes();
  enviaValores();
  MQTT.loop();
}

void mantemConexoes() {
    if (!MQTT.connected()) {
        conectaMQTT();
    }
}

void conectaWiFi() {
    WiFiManager wm;
    bool res;
    res = wm.autoConnect("Medidor de Energia");
    if(!res) {
        Serial.println("Wifi não conectado");
    }
    else {
        Serial.println("Wifi conectado");
    }
}

void conectaMQTT() {
    while (!MQTT.connected()) {
        Serial.print("Conectando ao Broker MQTT: ");
        Serial.println(BROKER_MQTT);
        if (MQTT.connect(ID_MQTT)) {
            Serial.println("Conectado ao Broker com sucesso!");
        }
        else {
            Serial.println("Noo foi possivel se conectar ao broker.");
            Serial.println("Nova tentatica de conexao em 10s");
            delay(10000);
        }
    }
}


void enviaValores() {

  // Calcula o valor da Corrente
  double Irms = emon1.calcIrms(1480);
  potencia = Irms * tensao;      
  Serial.println(Irms);

  // Crie um array de caracteres para armazenar a corrente como string
  char correnteStr[20];  // Defina um tamanho maior para acomodar a parte decimal
  
  // Converte o valor de ponto flutuante para string com 2 casas decimais
  dtostrf(Irms, 6, 2, correnteStr);
  
  // Publicando a mensagem no servidor broker
  MQTT.publish(TOPIC_PUBLISH, correnteStr); 

  // Exibindo a mensagem enviada no monitor serial
  Serial.print("Mensagem enviada:");
  Serial.println(correnteStr);
}
          </code>
        </pre>
        <p>O código inicia com a inclusão de bibliotecas essenciais: <strong>"EmonLib"</strong> para medição de energia. Declarações iniciais incluem a definição do pino do sensor SCT-013 e um valor de tensão fictício. No bloco de configuração <strong>setup()</strong>, o sensor SCT-013 é configurado com uma calibração de corrente específica.Dentro do ciclo principal <strong>loop()</strong>, a corrente eficaz é calculada usando <strong>calcIrms()</strong> da EmonLib. A potência instantânea é obtida multiplicando essa corrente pela tensão fictícia. As informações são então enviadas para o servidor broker. </p>
    </main>
</body>
</html>
